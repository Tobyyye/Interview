- 讲一下 hashMap 原理。hashMap 可以并发读么？并发写会有什么问题？

1.hashmap原理 Node<K,V>[] tab

2.add

3.get

4.扩容

5.并发读

6.并发写

https://zhuanlan.zhihu.com/p/79219960

这篇文章，希望能解决以下问题。

（1）HashMap的底层数据结构是什么？

（2）HashMap中增删改查操作的底部实现原理是什么？

（3）HashMap是如何实现扩容的？

（4）HashMap是如何解决hash冲突的？

（7）HashMap为什么是非线程安全的？

下面我们就带着这些问题，揭开HashMap的面纱。



**二、认识HashMap**

HashMap最早是在jdk1.2中开始出现的，一直到jdk1.7一直没有太大的变化。但是到了jdk1.8突然进行了一个很大的改动。其中一个最显著的改动就是：

> 之前jdk1.7的存储结构是数组+链表，到了jdk1.8变成了数组+链表+红黑树。

另外，HashMap是非线程安全的，也就是说在多个线程同时对HashMap中的某个元素进行增删改操作的时候，是不能保证数据的一致性的。



**1、底层数据结构**

为了进行一个对比分析，我们先给出一个jdk1.7的存储结构图

![img](https://pic4.zhimg.com/80/v2-13f265dfbfe4f6bf0505cd31d7b3cf47_720w.jpg)

从上图我们可以看到，在jdk1.7中，首先是把元素放在一个个数组里面，后来存放的数据元素越来越多，于是就出现了链表，对于数组中的每一个元素，都可以有一条链表来存储元素。这就是有名的“拉链式”存储方法。



这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高（链表不适合查找，适合增删），反倒是下降了不少，于是就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。

![img](https://pic2.zhimg.com/80/v2-14ccbe757a467d874cb7999f62caddcd_720w.jpg)

我们会发现优化的部分就是把链表结构变成了红黑树。原来jdk1.7的优点是增删效率高，于是在jdk1.8的时候，不仅仅增删效率高，而且查找效率也提升了。

**注意：不是说变成了红黑树效率就一定提高了，只有在链表的长度不小于8，而且数组的长度不小于64的时候才会将链表转化为红黑树，**

**问题一：什么是红黑树呢？**

红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找效率会从链表的o(n)降低为o(logn)。如果之前没有了解过红黑树的话，也没关系，你就记住红黑树的查找效率很高就OK了。



**问题二：为什么不一下子把整个链表变为红黑树呢？**

这个问题的意思是这样的，就是说我们为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？在这里可以从两方面来解释

（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。

（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会显著提高效率。

OK，到这里相信我们对hashMap的底层数据结构有了一个认识。现在带着上面的结构图，看一下如何存储一个元素。



**2、存储元素put**

我们在存储一个元素的时候，大多是使用下面的这种方式。

```java
public class Test {
    public static void main(String[] args) {
        HashMap<String, Integer> map= new HashMap<>();
        //存储一个元素
        map.put("张三", 20);
    }
}

```

在这里HashMap<String, Integer>，第一个参数是键，第二个参数是值，合起来叫做键值对。存储的时候只需要调用put方法即可。那底层的实现原理是怎么样的呢？这里还是先给出一个流程图





![img](https://pic3.zhimg.com/80/v2-bb8ee0ee1c0cc51537ae5f8e02038102_720w.jpg)

上面这个流程，不知道你能否看到，红色字迹的是三个判断框，也是转折点，我们使用文字来梳理一下这个流程：

（1）第一步：调用put方法传入键值对

（2）第二步：使用hash算法计算hash值

（3）第三步：根据hash值确定存放的位置，判断是否和其他键值对位置发生了冲突

（4）第四步：若没有发生冲突，直接存放在数组中即可

（5）第五步：若发生了冲突，还要判断此时的数据结构是什么？

（6）第六步：若此时的数据结构是红黑树，那就直接插入红黑树中

（7）第七步：若此时的数据结构是链表，判断插入之后是否大于等于8

（8）第八步：插入之后大于8了，就要先调整为红黑树，在插入

（9）第九步：插入之后不大于8，那么就直接插入到链表尾部即可。

上面就是插入数据的整个流程，光看流程还不行，我们还需要深入到源码中去看看底部是如何按照这个流程写代码的。



**3、扩容**

为什么扩容呢？很明显就是当前容量不够，也就是put了太多的元素。为此我们还是先给出一个流程图，再来进行分析。



**4、解决地址冲突**

解决地址冲突的前提是计算的hash值出现了重复，我们就先来看看HashMap中，是如何计算hash值的。

```java
static final int hash(Object key) {
     int h;
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

代码是超级简单，hash值其实就是通过hashcode与16异或计算的来的，为什么要使用异或运算呢？画一张图你就明白了：

![img](https://pic1.zhimg.com/80/v2-fe6755c8e427026b155c867f11efdbd0_720w.jpg)

也就是说，通过异或运算能够是的计算出来的hash比较均匀，不容易出现冲突。但是偏偏出现了冲突现象，这时候该如何去解决呢？



**5、构造一个HashMap**

上面可能出现的问题，我们都已经说明了，关于他的构造方法却姗姗来迟。下面我们好好说一下他的构造方法：

他的构造方法一共有四个：







**6、HashMap为什么是非线程安全的？**

想要解决这个问题，答案很简单，因为源码里面方法全部都是非线程安全的呀，你根本找不到synchronized这样的关键字。保证不了线程安全。于是出现了ConcurrentHashMap。

写到这里终于算是把一些核心的内容写完了。当然HashMap里面涉及到的面试题这些很多，不能能面面俱到。如有遗漏问题，会在今后补充。欢迎批评指正。







