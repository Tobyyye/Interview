https://www.cnblogs.com/marsitman/p/11228684.html

线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。

- 新建：就是刚使用new方法，new出来的线程；
- 就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
- 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
- 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
- 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

完整的生命周期图如下：



![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214114154-276488899.png)

**新建状态**

我们来看下面一段代码：

```
Thread t1 = ``new` `Thread();
```

这里的创建，仅仅是在JAVA的这种编程语言层面被创建，而在操作系统层面，真正的线程还没有被创建。只有当我们调用了 start() 方法之后，该线程才会被创建出来，进入Runnable状态。只有当我们调用了 start() 方法之后，该线程才会被创建出来

​                                           ![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214216437-864622217.png)

 

**就绪状态**

调用start()方法后，JVM 进程会去创建一个新的线程，而此线程不会马上被 CPU 调度运行，进入Running状态，这里会有一个中间状态，就是Runnable状态，你可以理解为等待被 CPU 调度的状态

```
t1.start()
```

用一张图表示如下：

![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214334481-1436365111.png)

那么处于Runnable状态的线程能发生哪些状态转变？

![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214414952-1788624892.png)

Runnable状态的线程无法直接进入Blocked状态和Terminated状态的。只有处在Running状态的线程，换句话说，只有获得CPU调度执行权的线程才有资格进入Blocked状态和Terminated状态，Runnable状态的线程要么能被转换成Running状态，要么被意外终止。

 

**运行状态**

当CPU调度发生，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法中逻辑代码。

那么处于Running状态的线程能发生哪些状态转变？

![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214456212-734896654.png)

- 被转换成Terminated状态，比如调用 stop() 方法;
- 被转换成Blocked状态，比如调用了sleep, wait 方法被加入 waitSet 中；
- 被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态；
- 被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中；
- 该线程的时间片用完，CPU 再次调度，进入Runnable状态；
- 线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态

 

**阻塞状态**

Blocked状态的线程能够发生哪些状态改变？

![img](https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190722214547127-782461177.png)

- 被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash;
- 被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后；
- 完成了指定时间的休眠，进入到Runnable状态；
- 正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态；
- 线程获取到了想要的锁资源，进入Runnable状态；
- 线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态；

 

**终止状态**

一旦线程进入了Terminated状态，就意味着这个线程生命的终结，哪些情况下，线程会进入到Terminated状态呢？

- 线程正常运行结束，生命周期结束；
- 线程运行过程中出现意外错误；
- JVM 异常结束，所有的线程生命周期均被结束。



# wait()和sleep()的区别

1. wait()来自Object类，sleep()来自Thread类
2. 调用 sleep()方法，线程不会释放对象锁。而调用 wait() 方法线程会释放对象锁；
3. sleep()睡眠后不出让系统资源，wait()让其他线程可以占用 CPU；
4. sleep(millionseconds)需要指定一个睡眠时间，时间一到会自然唤醒。而wait()需要配合notify()或者notifyAll()使用

sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法。例如，当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。并且可以调用notify（）方法或者notifyAll（）方法通知正在等待的其他线程。notify（）方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll（）方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁。具体区别如下：

1)  原理不同。sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，他会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。例如，当线程执行报时功能时，每一秒钟打印出一个时间，那么此时就需要在打印方法前面加一个sleep()方法，以便让自己每隔一秒执行一次，该过程如同闹钟一样。而wait()方法是object类的方法，用于线程间通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程调用notify（）方法或者notifyAll（）时才醒来，不过开发人员也可以给他指定一个时间，自动醒来。

2)  对锁的 处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。

3)  使用区域不同。wait()方法必须放在同步控制方法和同步代码块中使用，sleep()方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait()、notify（）、notifyAll（）不需要捕获异常。在sleep的过程中，有可能被其他对象调用他的interrupt（），产生InterruptedException。由于sleep不会释放锁标志，容易导致死锁问题的发生，因此一般情况下，推荐使用wait（）方法。

