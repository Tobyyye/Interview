Redis 内存淘汰策略

 LRU，TTL 

1、为什么需要内存淘汰策略
我们都知道Redis是一个基于k-v数据库，随着里面键值对的增加，redis内存的使用量也会上升，因此，我们需要对Redis的最大内存使用量进行限制。那么有了Redis的内存容量限制，那么就会有达到这个内存容量限制的时候，这个时候就需要对Redis存储的数据进行清理，释放内存，将Redis内存使用量保持在容量限制以下，淘汰数据的策略当然不是盲目的，是有策略的因此需要内存淘汰策略。

1、客户端执行一个新指令，添加数据

2、Redis检查内存使用量，如果大于maxmemory限制，就通过淘汰策略清理内存

3、执行新命令，重复上述过程

 

1.FIFO（First In First out）：先见先出，淘汰最先近来的页面，新进来的页面最迟被淘汰，完全符合队列。

2.LRU（Least recently used）:最近最少使用，淘汰最近不使用的页面

3.LFU（Least frequently used）: 最近使用次数最少， 淘汰使用次数最少的页面



4、Redis中的内存淘汰策略
1、noeviction:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，就返回error，然后啥也不干

2、allkeys-lru:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，就会扫描所有的key，淘汰一些最近未使用的key

3、volatile-lru:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，扫描那些设置里过期时间的key，淘汰一些最近未使用的key

4、allkeys-random:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，就会扫描所有的key，随机淘汰一些key

5、volatile-random:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，扫描那些设置里过期时间的key，随机淘汰一些key

6、volatile-ttl:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，扫描那些设置里过期时间的key，淘汰一些即将过期的key

7、volatile-lfu:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，就会淘汰一些设置了过期时间的，并且最近最少使用的key

8、allkeys-lfu:添加数据时，如果redis判断该操作会导致占用内存大小超过内存限制，就会扫描所有的key，淘汰一些最近最少使用的key





7、内存淘汰策略的选择(个人观点)
我们在选择使用淘汰策略的时候可以根据访问key的方式来选择不同的淘汰策略

1、当我们redis中的key基本上都有用到，也就是说每个key都有周期性访问到，那就可以选择使用random策略

2、当我们redis中的key部分是我们经常访问的，部分是非经常访问的就可以考虑使用LRU和LFU策略

3、当我们想根据时间长久淘汰超时数据时，就选用ttl

4、我们根据我们的需要是否有要长久保存的key来选择volatile或者是all，如果有需要长久保存的key，则使用volatile，否则可以使用all全表扫描
