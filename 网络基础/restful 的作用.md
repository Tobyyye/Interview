# restful的优点

轻量，直接基于http，不再需要任何别的诸如消息协议。get/post/put/delete为CRUD操作

面向资源，一目了然，具有自解释性。

数据描述简单，一般以xml，json做数据交换。

无状态，在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。

简单、低耦合


1. 3.遵循REST规范的Web应用将会获得下面好处：

a.URL具有很强可读性的，具有自描述性；

b.资源描述与视图的松耦合；

c.可提供OpenAPI，便于第三方系统集成，提高互操作性；

d.如果提供无状态的服务接口，可提高应用的水平扩展性



某人的理解

https://www.bbsmax.com/A/Gkz16GWNJR/



 **restful** 

https://www.zhihu.com/question/28557115







https://www.zhihu.com/question/28557115

### REST的约束条件

### 协议选择

`REST` 本身并没有提到底层应该使用什么协议，日常实践案例中最常用的是基于 `HTTP` 的 `RESTful` 实现。

这是因为 `HTTP` 协议自带的动词 `GET/POST/PUT/DELETE` 可以作为推动状态转移的方法，另外`HTTP` 的制定了规范的状态码。还有其他的一些 `HTTP` 特性，这些特性使得在`HTTP` 之上实现 `REST` 要简单得多，而如果使用其他协议的话，就需要自己实现这些特性。

### 请求规范

`RESTful` 架构中，发生状态转换的是「资源」，所以`URI` 中一般只能包含代表「资源」的名词，并且推荐是复数，而不应该在 `URI` 中包对资源进行操作的动词。

对资源执行的`CURD「增删改查」`动作应该在`HTTP`请求方法的`GET/POST/PUT/DELETE`中体现。

符合REST规范的写法：

```text
POST http://www.test.com/lemon   // 创建
Get http://www.test.com/lemon    // 查询
PUT http://www.test.com/lemon    // 修改
DELETE http://www.test.com/lemon //删除
```

不符合REST规范的写法：

```text
POST http://www.test.com/Createlemon  // 创建
POST http://www.test.com/Querylemon   // 查询
POST http://www.test.com/Modifylemon  // 修改
POST http://www.test.com/Deletelemon  //删除
```



作者：程序员柠檬

### 状态码

服务端消息响应携带状态码，指示客户端进行下一步处理。符合 `RESTful` 规范的接口返回状态码都是通用的，不需要额外约定，利用`HTTP Status Code 状态码` 表示请求处理结果，降低了微服务间互操作成本。

| 状态码 | 状态码含义 | | ------ | ---------------------------------------------- | | 2xx | 成功，操作被成功接收并处理 | | 3xx | 重定向，需要进一步的操作以完成请求 | | 4xx | 客户端错误，请求包含语法错误或无法完成请求 | | 5xx | 服务器错误，服务器在处理请求的过程中发生了错误 |

下面是常见的`HTTP`状态码：

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误



### 无状态

`RESTful`接口要求是「无状态」。无状态指的是任意一个Web请求必须完全与其他请求隔离，当客户端发起请求时，消息本身包含了服务端识别这一请求上下文所需的全部信息。

### 无状态不是真的没有状态

接口「无状态」更确切的说是服务端无状态，整个会话还是需要状态维持的。要完成一个业务流程，一般客户端与服务端需要多次的消息交互，我们知道`HTTP` 协议是「无状态协议」，这就需要服务端能够识别几个独立 `HTTP` 请求的「状态信息」，从而将他们关联到一个业务流程中。

还是举例子银行系统取款的例子：

- 用户lemon要登录银行系统，首先需要在登录页面输入用户名和密码，这时候产生一个登录请求
- 服务端收到登录请求，执行登录逻辑并返回操作结果
- lemon登录之后点击取款100万，产生一个取款请求
- 服务端收到取款请求，执行取款逻辑并返回操作结果



![img](https://pic1.zhimg.com/50/v2-bc1094d515fc49cf038de690fb5b52db_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-bc1094d515fc49cf038de690fb5b52db_720w.jpg?source=1940ef5c)



这里有个问题，服务端在不同时间点收到登录请求和取款请求，这两个请求都是用户 `lemon` 产生的，如果不在技术层面做对独立的 `HTTP` 请求做关联的话，服务端就无法知道这两个请求其实是都是用户`lemon` 「取款业务」的组成部分。

### 技术方案

服务端要能识别请求的「状态信息」，有两种技术方案：

1. `Session` 方式。服务端保存会话状态，客户端每次请求携带`session-id`。

服务端维护一个会话状态信息列表，用`session-id`唯一标识一个状态信息，`session-id`一般包含在`HTTP`响应的`Set-Cookie`头部返回给客户端，后续客户端请求携带包含`session-id`信息的`cookie`头部，服务端解析`cookie`取出`session-id`，去维护的状态列表中取回该消息对应的状态信息，这样就把无状态的`HTTP`变成有状态的了。



![img](https://pic4.zhimg.com/50/v2-11e54ff5685965877c72c2a67c543fc8_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-11e54ff5685965877c72c2a67c543fc8_720w.jpg?source=1940ef5c)



1. `Token` 方式。服务端不保存会话状态，客户端每次请求都携带完整的会话状态信息（一般是加密的）给服务端。

`Token`也称作是「令牌」或临时证书签名，状态信息都被加密到`token`中，这样每当服务器收到请求后解密`token`就能获取该请求对应的状态信息，也就能把不同的请求消息关联到同一个业务流程中来，和`session`方式有类似的效果，只不过这次的状态信息不保存在服务端。



![img](https://pic1.zhimg.com/50/v2-88351e275ce473fee8398d3d2b71478d_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-88351e275ce473fee8398d3d2b71478d_720w.jpg?source=1940ef5c)



以上两种实现中，第一种 `Session` 方式是有状态的，第二种 `Token` 方式是无状态的。

如果你要实现 `RESTful` 接口最好按第二种技术方案实现，当然要实现无状态也还有其他方式，思路都是「服务端不保持会话状态」就对了。

### 为什么要无状态

为了高可用性和负载均衡需求，多个微服务通过负载均衡实现分布式集群化部署，集群中每个服务都是独立和对等的。如果服务器在收到客户端请求之时不可用或者宕机，无状态请求可以由任何其他可用服务器处理并作出应答，这在分布式应用中非常重要。



![img](https://pic3.zhimg.com/50/v2-5c08d333a2591a72f217345412942e62_hd.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-5c08d333a2591a72f217345412942e62_720w.jpg?source=1940ef5c)



想象一下如果服务端保存状态，一个事务内的每个请求都必须落到同一台服务器去处理，这就失去了分布式的意义和优势。

所以， `RESTful` 接口要求是无状态的，是为了更好的适应分布式业务场景，发挥微服务集群优势。

### REST 和 RPC

这两个概念经常出现在微服务架构设计中，`REST` 是一种软件架构接口设计风格，`RPC` 是一种计算机通信协议，看起来是两个不同的概念，要把他们放在一起比较的话，我个人倾向于把 `REST` 具体化为一种基于`HTTP` 并按照 `REST` 约束设计的通信协议，两个通信协议之间还是可以比较一下的。

### 回顾下RPC

`RPC (Remote Procedure Call)`远程过程调用是一个计算机通信协议。我们一般的程序调用是本地程序内部的调用，`RPC`允许你像调用本地函数一样去调用另一个程序的函数，这中间会涉及网络通信和进程间通信，但你无需知道实现细节，`RPC`框架为你屏蔽了底层实现。`RPC` 是一种服务器-客户端`Client/Serv er`模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。

### 适用场景

很多 `RPC` 框架提供的消息传输都是基于二进制的，比如`Thrift`、`Protocol buffers`。这样做的好处是消息结构比较紧凑，对于频繁调用或者大流量、低时延要求的应用场景，能够显著减少网络开销；另一个约束是某些 `RPC` 框架有很强的技术耦合性，比如 `Dubbo` 只能用于 `java` 技术栈。综上，`RPC` **更加适用于系统内部微服务之间的高效通信。**

`RESTful`接口由于提供了统一的基于 `HTTP`的 `REST` 设计标准，只需 `web` 框架支持 `HTTP` 协议，并设计`RESTful` 风格的接口即可，极大的方便了第三方服务接入调用，**适合用于微服务系统对外暴露的接口设计标准。**



## 好在何处

1，语义明确，较为流行

2，简单明了，有规范，有约定



## 不好的地方

1，过于死板，如果是一个「REST原教旨主义者」，编写HTTP API应该很痛苦

2，有些需求，使用REST来解决，不是很适合，比如「登录动作」



## 化繁为简，实用至上

1，REST鼓励我们使用四个HTTP 动作，我们仍然使用。它们是：GET，POST，PUT，DELETE。坦白说，这四个方法够用了，足够覆盖大部分场景

2，简化资源的增删改查。比如按照REST的语义，一个资源的操作，一般会有如下几个API：

- 创建：POST /resources
- 删除：DELETE /resources/{id}
- 修改：PUT /resources/{id}
- 查询一个：GET /resources/{id}
- 查询批量：GET /resources

我认为，搞出这么多API，是没有啥很大意义的，API多了也是一种痛苦，不如精简。比较可以精简如下：

- 创建（一个，或者多个）：POST /resources 在请求体中，用数组表示
- 删除（一个，或者多个）：POST /resources/delete 在请求体中，传多个id
- 修改（一个，或者多个）：PUT /resources 在请求体传递数据
- 查询（一个，或者多个）：GET /resources?id=XXX 传了id表示查询某一个，没传表示查询全部

3，诸如登录、登出操作，直接设计API即可，不用理会REST规范。比如：/login，/logout



