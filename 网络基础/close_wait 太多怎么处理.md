 **close_wait 太多怎么处理？为什么会出现这种情况？****

https://blog.csdn.net/xifeijian/article/details/44284675

# TCP协议－－CLOSE_WAIT状态

1.服务器异常

如果服务器出了异常，十之八九都是以下两种情况：

1.服务器保持了大量TIME_WAIT状态

2.服务器保持了大量CLOSE_WAIT状态


因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着应用程序可能返回大量Too Many Open Files异常。

2.Close_Wait引发的问题
Close_Wait会占用一个连接，网络可用连接小。数量过多，可能会引起网络性能下降，并占用系统非换页内存。 尤其是在有连接池的情况下(比如HttpRequest)
会耗尽连接池的网络连接数，导致无法建立网络连接。

3.解决方法

下面来讨论下这两种情况的处理方法，优化系统内核参数解决TIME_WAIT可能很容易，可以通过修改/etc/sysctl.conf文件解决；

但是应对CLOSE_WAIT的情况还是需要从程序本身出发。因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。从上面的图可以看出来，**如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出FIN信号，一般原因都是TCP连接没有调用关闭方法。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着**。这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行，一定程度上，可以使用TCP的**KeepAlive**功能，让操作系统替我们自动清理掉CLOSE_WAIT连接。





https://www.cnblogs.com/grey-wolf/p/9945637.html