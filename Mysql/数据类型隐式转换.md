# 字段类型不同造成的隐式转换，导致索引失效



## 什么是隐式类型转换

> 在MySQL中，当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。则会发生转换隐式

也就是说,MySQL会根据需要自动将数字转换为字符串，将字符串转换数字。

这里因为存在-号，隐式类型转化将' '和' and password = '字符串进行了算术运算，转为成数字类型。

 

这里再举两个例子

案例一:字符串转换为数字



```
mysql > SELECT 1+'1';
```

结果:



```
mysql > 2
```

案例二: 数字转换为字符串



```
mysql -> SELECT CONCAT(1024,' andyqian');
```

结果:



```
'1024,' andyqian';
```







## 小心隐式类型转换

这里再重申一次,写SQL时一定要检查参数类型与数据库字段类型一致,(如果参数不一致,也要使用CAST函数显示转换成一致)否则造成隐式类型转换,不走索引,后果简直不堪设想, 在前面[《写会MySQL索引》](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2NDU3OTg5Nw%3D%3D%26mid%3D2247483736%26idx%3D1%26sn%3De3fa0bf61b77c9ca12ee1d295c51313a%26scene%3D21%23wechat_redirect)这篇文章中提到过,不走索引,轻则造成慢查询，重则造成数据库服务器CPU100%。唉,说到这里,不瞒你说，我就吃过不少MySQL隐式类型转换的亏 ! (如慢查询) !





https://www.jb51.net/article/101531.htm



https://www.yht7.com/news/120007



#### 谈谈MySQL中的隐式转换

-  作者：佚名  来源： 网络转载
-  

-  时间：2020-10-27

工作过程中会遇到比较多关于隐式转换的案例，隐式转换除了会导致慢查询，还会导致数据不准。本文通过几个生产中遇到的案例来。

**基础知识**

关于比较运算的原则,MySQL官方文档的描述: https://dev.mysql.com/doc/refman/5.6/en/type-conversion.html

> 如果 判断符号左右两边有一个为NULL,结果就是null，除非使用安全的等值判断 <=> 

```
(none) 05:17:16 >select  null = null;
+-------------+
| null = null |
+-------------+
|        NULL |
+-------------+
1 row in set (0.00 sec)

(none) 05:34:59 >select  null <=> null;
+---------------+
| null <=> null |
+---------------+
|             1 |
+---------------+
1 row in set (0.00 sec)

(none) 05:35:51 >select  null != 1;
+-----------+
| null != 1 |
+-----------+
|      NULL |
+-----------+
1 row in set (0.00 sec)
```

> 如何判断左右两边都是相同类型的，比如都是字符串，则以字符串进行对比。如果是数字，则以数字进行比较。

注意 对于比较常见的 字符串与数字类型的比较的情况，如果字符串字段是索引字段，那么MySQL 无法通过索引进行查找数据,比如以下例子:

```
(none) 05:39:42 >select  1="1";
+-------+
| 1="1" |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)

(none) 05:39:44 >select  1="1A";
+--------+
| 1="1A" |
+--------+
|      1 |
+--------+
1 row in set, 1 warning (0.00 sec)

(none) 05:39:47 >select  1="1 "; ##1后有空格
+--------+
| 1="1 " |
+--------+
|      1 |
+--------+
1 row in set (0.00 sec)
```

MySQL 认为数字1 与"1","1_","1A" 相等，故无法通过索引二分查找准确定位到具体的值。

> Hexadecimal(十六进制)以二进制字符串的方式进行比较。
>
> 如何判断符号左边是 timestamp 或者datetime类型的，右边是常量，在比较之前，常量会被转换为时间类型。

**隐式转换
**

**字段类型不一样**

> In all other cases, the arguments are compared as floating-point (real) numbers.

除了以上的其他类型的比较，系统将字段和参数转换为浮点型进行比较。使用浮点数（或转换为浮点数的值）的比较是近似的，因为这样的数字是不精确的。看下面2个例子

```
>select "190325171202362933" = 190325171202362931;
+-------------------------------------------+
| "190325171202362933" = 190325171202362931 |
+-------------------------------------------+
|                                         1 |
+-------------------------------------------+
1 row in set (0.00 sec)

>select "190325171202362936" = 190325171202362931;
+-------------------------------------------+
| "190325171202362936" = 190325171202362931 |
+-------------------------------------------+
|                                         1 |
+-------------------------------------------+
1 row in set (0.00 sec)
```

直观上不相等的值，做等值判断之后竟然返回为1。这样带来2个问题不能利用索引且结果数据不准

```
>select "190325171202362931"+0.0;
+--------------------------+
| "190325171202362931"+0.0 |
+--------------------------+
|    1.9032517120236294e17 |
+--------------------------+
1 row in set (0.00 sec)

>select "190325171202362936"+0.0;
+--------------------------+
| "190325171202362936"+0.0 |
+--------------------------+
|    1.9032517120236294e17 |
+--------------------------+
1 row in set (0.00 sec)
```

将上面的值转换为浮点数,都是 1.9032517120236294e17，所以判断相等时为真，返回True。