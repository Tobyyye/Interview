主键选随机 id、uuid 还是自增 id？为什么？



**mysql不要用uuid用自增主键，自增主键效率高innodb的索引特性导致了自增id做主键是效率最好的**

**分别对自增主键和uuid主键记录表进行性能测试**



自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。

插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。
自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

**而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。**

- 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。
**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

**所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。**

1.方便排序uuid是随机生成的，id是自增方便排序

2.个数自增id最大值是几百万，基本不会出现



主键有序无序对数据库的影响

。GUID（全局唯一标识符），也称为UUID，长128-bit的值，能保证在所有时间和空间上独一无二。RFC 41222 描述了创建标准GUID,如今大多数GUID生成算法通常是一个很长的随机数，再结合一些像网络mac地址这种随机本地组件信息。

GUID允许开发人员自行创建而不需要服务器去检查是否已被他人使用导致冲突，咋一看，这是一种很好的解决方案。

那么问题是什么呢？性能。为了得到最好的新能，很多数据库都使用聚焦索引，意味着表中的行的顺序（通常基于主键）也是对应存储在磁盘中的的顺序。这使得其能通过索引快速查找，但它也导致在插入 【主键不是在列表的末尾的（their primary key doesn't fall at the end of the list）】  新行时变得很慢。例如下面的数据：

但它也导致在插入 【主键不是在列表的末尾的（their primary key doesn't fall at the end of the list）】 新行时变得很慢。例如下面的数据：

| **ID** | **Name**     |
| ------ | ------------ |
| 1      | Holmes, S.   |
| 4      | Watson, J.   |
| 7      | Moriarty, J. |

此时很简单：数据行对应ID列顺序储存。如果我们新添加一行ID为8，也不会产生问题，新行会附加的末尾。

| **ID** | **Name**     |
| ------ | ------------ |
| 1      | Holmes, S.   |
| 4      | Watson, J.   |
| 7      | Moriarty, J. |
| 8      | Lestrade, I. |

但如果我们想插入一行的ID为5: 

| **ID** | **Name**     |
| ------ | ------------ |
| 1      | Holmes, S.   |
| 4      | Watson, J.   |
| 5      | Hudson, Mrs. |
| 7      | Moriarty, J. |
| 8      | Lestrade, I. |

ID7,8行必须移动。虽然在这里不算什么事儿，但当你的数据量达到数百万行的级别之后，这就是个问题了。如果你还想要每秒处理上百次这种请求，那可真是难上加难了

 这就是GUID主键引发的问题：它可能是真正随机生成的，至少表面看起来很像是随机的，因为它们通常不会产生任何特定的顺序。正因为如此，使用一个  GUID 值作为任何规模的数据库中的主键的一部分被认为是非常糟糕的做法。 导致插入会很慢，还会涉及大量的不必要的磁盘活动。 









## MySQL分布式架构的取舍

分布式架构，意味着需要多个实例中保持一个表的主键的唯一性。这个时候普通的单表自增ID主键就不太合适，因为多个mysql实例上会遇到主键全局唯一性问题。





最近遇到了要选择String类型通过uuid设置实体类id好还是选择数字整型设置成数据库自增好的问题，
总结了一下两者的优缺点：
用数据库自增id的优点：
首先字段长度较uuid小很多，可以是bigint甚至是int类型，这对检索的性能会有所影响。我们平时数据库一般用的都是innodb引擎的表，这种表格检索数据的时候，哪怕走索引，也是先根据索引找到主键，然后由主键找到这条记录。所以主键的长度短的话，读性能是会好一点的。
在写的方面，因为是自增的，所以主键是趋势自增的，也就是说新增的数据永远在后面，这点对于性能有很大的提升（这点我接下来会在uuid的优缺点分析中解释，虽然用词可能不太专业）。

用数据库自增id的缺点：
最致命的一个缺点就是，很容易被别人知晓业务量，然后很容易被网络爬虫教做人
高并发的情况下，竞争自增锁会降低数据库的吞吐能力
数据迁移的时候，特别是发生表格合并这种操作的时候，会非常蛋疼

接下来说下uuid的优点：
基本不会有冲突的情况，这个也是uuid比较好的一个方面，更具有唯一性
可以在应用层生成，提高数据库吞吐能力
是string类型，写代码的时候方便很多

uuid的缺点
与自增相比，最大的缺陷就是随机io。这一点又要谈到我们的innodb了，因为这个默认引擎，表中数据是按照主键顺序存放的。也就是说，如果发生了随机io，那么就会频繁地移动磁盘块。当数据量大的时候，写的短板将非常明显。当然，这个缺点可以通过nosql那些产品解决。
读取出来的数据也是没有规律的，通常需要order by，其实也很消耗数据库资源
