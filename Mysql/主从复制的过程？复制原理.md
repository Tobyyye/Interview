- 主从复制的过程？复制原理？怎么保证强一致性？ 

https://www.cnblogs.com/shenjianping/p/13605511.html

## 一、主从复制

### （一）主从复制介绍

 　MySQL支持单向、双向、链式级联、实时、异步复制。在复制过程中，一台服务器充当主服务器（Master），而一个或多个其它的服务器充当从服务器（Slave）。

　　复制可以是单向：M-->S，也可以是双向：M<-->M，或者多M环状同步等。

　　如果设置了链式级联复制，那么从slave服务器本身充当从服务器外，也会同时充当其下从服务器的主服务器。下面是几种逻辑图：

#### 1、主从同步逻辑图

- 单向主从同步

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905171131014-1905763618.png)

- 一主两从或多从

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905171705259-1335684750.png)

- 双向主主同步（互为主从）

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905172138346-2070572140.png)

- 线性级联单向双主同步

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905172516248-1499719222.png)

-  单向环状级联同步

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905172948873-1201255383.png)

- 单向环状级联多主多从同步

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200905173355254-1878298221.png)

 　上面这么多的结构，那么因该如何选择呢？一般情况选择单向主从同步（图1），一主两从或多从（图2），单向线性级联同步（图4）可满足大部分的工作场景。大多数应用MySQL主从同步都是异步的复制方式（不是严格的实时数据同步）。

　　当配置好主从复制后，所有对数据库内容的更新操作必须在主服务器上进行，以避免用户对主服务器上数据库内容的更新与对从数据库上数据库内容的更新不一致导致发生冲突

#### 、主从复制应用场景

- 主从服务器互为备份

主从服务器架构的设置，可以大大加强数据库架构的健壮性。当主服务出项问题时，可以手动或者自动切换到从服务器继续提供服务。

- 主从服务器读写分离分担网站压力

　　主从服器器架构可以通过程序或者代理软件实现对用请求的读写分离。即通过在从服务器上仅仅处理用户的查询请求（select），降低用户查询响应时间以及读写同时在主服务器上带来的压力。对于更新的数据（insert、update、delete）仍然交给主服务器处理，确保主服务器和从服务器保持实时同步。

-  服务器根据业务拆分独立分担压力

　　根据公司不同的业务，使用不同的从服务器来承担不同的模块。比如，一个网站有专门为用户提供的前台页面，帮用户提供查询等服务；另外有自己的后台管理，可用于上传前台需要展示的一些内容；还有就是一个从服务器专门用来对数据进行备份。

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200906093541141-1241443990.png)

### （二）主从复制实现原理

 

####  1、如何实现主从复制

- 通过程序

　　通过java或者Python等语言设置多个连接实现对数据库的读写分离，即当查询（select）时，就去连接读库的连接文件，当更新（update、insert、delete）时就去连接写库的连接文件。

- 通过软件

MySQL-proxy等代理软件可以实现读写分离的功能。



#### 2、主从复制实现过程

![img](https://img2020.cnblogs.com/blog/1137363/202009/1137363-20200906103636613-397509942.png)

 主从复制实现的过程：

（1）Slave服务器上执行 start slave，开启主从复制开关。

（2）此时，Slave服务器上的IO线程会通过在Master授权的复制用户权限请求连接Master服务器，并且请求从指定binlog日志文件的指定位置（日志文件名和位置是在配置主从复制服务时执行change master命令时指定）后发送binlog日志内容。

（3）Master服务器接收来自Slave服务器的IO线程请求后，Master服务器上负责复制的IO线程根据Slave服务器的IO线程请求的信息读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回信息中除了binlog日志内容外，还有本次返回日志内容后的Master服务端新的binlog文件名称以及binlog中的下一个指定更新位置。

（4）当Slave服务器的IO线程获取来自Master服务器上IO线程发送的日志内容及日志文件和位置点后，将binlog日志内容依次写入到Slave端的Relay  Log（中继日志）文件的最末端，并将新的binlog日志文件名和位置记录到master-info文件中，以便下一次读取Master端新的binlog日志能够告诉Master服务器需要从新的binlog日志的那个文件那个位置开始请求新的binlog日志内容。

（5）Slave服务端的SQL线程会实时检测本地的Relay Log中新增加的日志内容，然后及时的把Log文件中的内容解析成在Master端能够执行的SQL语句内容，并且在Slave服务器上按语句顺序执行应用这些SQL语句，应用完毕后清理应用过的日志。

（6）经过上述过程，就可以确保Mster端和Slave端执行了相同的SQL语句。当复制状态正常时，Master端和Slave端的数据是完全一样的。

https://www.cnblogs.com/shenjianping/p/13605511.html



## 关于主从复制

现在常用的MySQL高可用方案，十有八九是基于 MySQL的主从复制（replication）来设计的，包括常规的一主一从、双主模式，或者半同步复制（semi-sync replication）。

我们常常把MySQL replication说成是MySQL同步（sync），但事实上这个过程是异步（async）的。大概过程是这样的：

1. 在master上提交事务后，并且写入binlog，返回事务成功标记；
2. 将binlog发送到slave，转储成relay log；
3. 在slave上再将relay log读取出来应用。

步骤1和步骤3之间是异步进行的，无需等待确认各自的状态，所以说MySQL replication是异步的。

MySQL semi-sync replication在之前的基础上做了加强完善，整个流程变成了下面这样：

1. 首先，master和至少一个slave都要启用semi-sync replication模式；
2. 某个slave连接到master时，会主动告知当前自己是否处于semi-sync模式；
3. 在master上提交事务后，写入binlog后，还需要通知至少一个slave收到该事务，等待写入relay log并成功刷新到磁盘后，向master发送“slave节点已完成该事务”确认通知；
4. master收到上述通知后，才可以真正完成该事务提交，返回事务成功标记；
5. 在上述步骤中，当slave向master发送通知时间超过rpl_semi_sync_master_timeout设定值时，主从关系会从semi-sync模式自动调整成为传统的异步复制模式。

半同步复制看起来很美好有木有，但如果网络质量不高，是不是出现抖动，触发上述第5条的情况，会从半同步复制降级为普通复制；此外，采用半同步复制，会导致master上的tps性能下降非常严重，最严重的情况下可能会损失50%以上。

这样来看，除非需要非常严格保证数据一致性等迫不得已的场景，就不太建议使用半同步复制了。当然了，事实上我们也可以通过加强程序端的逻辑控制，来避免主从数据不一致时发生逻辑错误，比如说如果在从上读取到的数据和主不一致的话，那么就触发主从间的一次数据修复工作。或者，我们也可以用 pt-table-checksum & pt-table-sync 两个工具来校验并修复数据，只要运行频率适当，是可行的。

真想要提高多节点间的数据一致性，可以考虑采用PXC方案。现在已知用PXC规模较大的有qunar、sohu，如果团队里初期没有人能比较专注PXC的话，还是要谨慎些，毕竟和传统的主从复制差异很大，出现问题时需要花费更多精力去排查解决。

## 如何保证主从复制数据一致性



上面说完了异步复制、半同步复制、PXC，我们回到主题：在常规的主从复制场景里，如何能保证主从数据的一致性，不要出现数据丢失等问题呢？

在MySQL中，一次事务提交后，需要写undo、写redo、写binlog，写数据文件等等。在这个过程中，可能在某个步骤发生crash，就有可能导致主从数据的不一致。为了避免这种情况，我们需要调整主从上面相关选项配置，确保即便发生crash了，也不能发生主从复制的数据丢失。

#### 1. 在master上修改配置

> ```
> innodb_flush_log_at_trx_commit = 1
> sync_binlog = 1
> ```

上述两个选项的作用是：**保证每次事务提交后，都能实时刷新到磁盘中，尤其是确保每次事务对应的binlog都能及时刷新到磁盘中**，只要有了binlog，InnoDB就有办法做数据恢复，不至于导致主从复制的数据丢失。

#### 2. 在slave上修改配置

> ```
> master_info_repository = "TABLE"
> relay_log_info_repository = "TABLE"
> relay_log_recovery = 1
> ```

上述前两个选项的作用是：**确保在slave上和复制相关的元数据表也采用InnoDB引擎，受到InnoDB事务安全的保护**，而后一个选项的作用是**开启relay log自动修复机制，发生crash时，会自动判断哪些relay log需要重新从master上抓取回来再次应用，以此避免部分数据丢失的可能性。**

通过上面几个选项的调整，就可以确保主从复制数据不会发生丢失了。但是，**这并不能保证主从数据的绝对一致性**，因为，有可能设置了ignore\do\rewrite等replication规则，或者某些SQL本身存在不确定因素，或者人为在slave上修改数据，最终导致主从数据不一致。这种情况下，可以采用pt-table-checksum 和 pt-table-sync 工具来进行数据的校验和修复。