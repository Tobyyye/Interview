https://www.cnblogs.com/xhy-shine/p/11275850.html



目录

一、什么是自动垃圾回收？
第一步：标记
第二步：清除
为什么需要分代垃圾收集 
JVM 分代
二、世代垃圾收集过程

自动垃圾回收时一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。所谓使用中的对象（已引用对象），指的是程序汇总有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。

在用C之类的编程语言时，程序员需要自动手动分配和释放内存。而Java不一样，它有垃圾回收器，释放内存由回收器负责。本文接下来将介绍垃圾回收机制的基本过程。


第一步：标记垃圾回收的第一步是标记。垃圾回收器此时会找出哪些内存在使用，还有哪些不是。



上图中，蓝色表示已引用对象，橙色表示未引用对象。垃圾回收器要检查完所有的对象，才能知道哪些有被引用，哪些没。如果系统里所有的对象都要检查，那这一步可能会相当耗时间。

 

第二步：清除
这一步会删掉标记处的未引用对象。



内存分配器会保留指向可用内存的引用，以供分配新对象。

压缩

为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。

为什么需要分代垃圾收集 
之前说过，逐一标记和压缩Java虚拟机里的所有对象非常低效：分配的对象越多，垃圾回收需要的时间就越久。不过，根据统计，大部分的对象，其实用没多久就不用了。

来看个例子吧。（下图中，竖轴代表已分配的字节，而横轴代表程序运行时间）

上图可见，存活（没被释放）的对象随运行时间越来越少。而图中左侧的那些峰值，也表明了大部分对象的寿命都很短


![img](https://img2018.cnblogs.com/blog/1328740/201907/1328740-20190731151307157-1929557400.png)



JVM 分代
根据之前的规律，就可以用来提升JVM的效率了。方法是，把堆分成几个部分（就是所谓的分代），分别是新生代、老年代、永久代。

![img](https://img2018.cnblogs.com/blog/1328740/201907/1328740-20190731151719050-655966316.png)

新对象会被分配在新生代内存中。一旦新生代内存满了，就会开始触发小型垃圾回收，对死掉的对象进行清理。新生代内存，死掉的越多，回收过程就越快；至于那些还存活的对象，此时就会增加年龄老化，并最终进入到老年代内存。

Stop the World事件——所有的小型垃圾回收都属于一种叫“Stop the World”的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止。

老年代用来保存长时间存活的对象。通常，设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个实践称为Major GC。

Major GC也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受老年代垃圾回收器类型的影响。

永久代包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。



如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。



二、世代垃圾收集过程

非常清晰的直观的解释

https://www.cnblogs.com/xhy-shine/p/11275850.html