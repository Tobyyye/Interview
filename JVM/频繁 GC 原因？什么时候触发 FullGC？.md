# [什么时候会触发Full GC](https://www.cnblogs.com/jiagoujishu/p/13825771.html)



**1.** **调用** **System.gc()**

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

**2. 未指定老年代和新生代大小，堆伸缩时会产生fullgc,所以一定要配置-Xmx、-Xms**

**3.** **老年代空间不足**

老年代空间不足的常见场景比如大对象、大数组直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。

除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。

还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

在执行Full GC后空间仍然不足，则抛出错误：`java.lang.OutOfMemoryError: Java heap space`

**4. JDK 1.7** **及以前的（永久代）空间满**

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静

态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也

会执行 Full GC。

如果经过 Full GC 仍然回收不了，那么虚拟机会抛出`java.lang.OutOfMemoryError PermGen space`

为避免以上原因引起的 Full GC，可采用的方法为增大Perm Gen或转为使用 CMS GC。

**5.** **空间分配担保失败**

空间担保，下面两种情况是空间担保失败：

1、每次晋升的对象的平均大小 > 老年代剩余空间

2、Minor GC后存活的对象超过了老年代剩余空间

注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当出现这两种状况的时候就有可能会触发Full GC。

promotion failed 是在进行 Minor GC时候，survivor space空间放不下只能晋升老年代，而此时老年代也空间不足时发生的。

concurrent mode failure 是在进行CMS GC过程，此时有对象要放入老年代而空间不足造成的，这种情况下会退化使用Serial Old收集器变成单线程的，此时是相当的慢的。

**怎么调优**

围绕一个点，策略就是尽量把对象在新生代使用回收，减少晋升老年代的几率

Full GC本身是好的，可以清除老年代的垃圾，但是如果Full GC发生的频率高了，就会影响性能，同时意味着系统内存分配机制出现问题。
因为Full GC本身执行时间较长（甚至超过1秒），而且除非采用G1 GC，否则其它的GC方式都会或多或少挂起所有线程执行（Stop-the-world），如果Full GC频繁发生，系统被挂起的次数就会增加，响应时间就会变慢。
同时，Full GC频繁发生，意味着你的内存分配机制存在问题，也许是内存泄露，有大量内存垃圾不断在老年代产生；也许是你的大对象（缓存）过多；也有可能是你的参数设置不好，minor GC清理不掉内存，导致每次minor GC都会触发Full GC；还有可能是你的老年代大小参数设置错误，老年代过小等等原因





**频繁 GC 原因** 

1.内存抖动，即大量的对象被创建又在短时间内被释放2.瞬间产生大量的对象会严重占用内存区域



- 以上重显代码可以看出metricsMap中的元素是会越来越多的。如果就这样下去，最终的结果也会出现OOM。
- 根本原因还是对ThreadPoolExecutor不够熟悉，所以出现了这次问题。
- 个人感觉Full GC类问题是比较让人头疼的。这些问题并不会想代码语法问题一样，ide会提示我们具体错在哪里，我们只要修改对应地方基本都能解决。造成Full GC频繁的原因也有很多，比如可能是jvm参数设置不合理、Metaspace空间触发、频繁创建对象触发等等。
- 如果确定了是频繁创建对象导致，那么接下来的目的就是确定频繁创建对象的对应代码处，这时候可以选择通过dump线上堆栈，然后下载到本地。选择一些可视化分析工具进行分析。最终定位到出问题的代码处，然后解决问题。